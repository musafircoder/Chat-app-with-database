from fastapi import FastAPI, WebSocket
from fastapi.responses import HTMLResponse
from typing import List
from database import Base, engine, SessionLocal, Message
from sqlalchemy.orm import Session

app = FastAPI()

# Create DB tables
Base.metadata.create_all(bind=engine)


# ---------------- DB Dependency ----------------
def get_db():
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# ---------------- Frontend ----------------
html = """
<!DOCTYPE html>
<html>
    <head>
        <title>FastAPI Chat</title>
    </head>
    <body>
        <h1>Welcome to MUSAMI CHAT!</h1>
        <h2>Your ID: <span id="ws-id"></span></h2>
        <ul id="messages"></ul>
        <input id="msg" autocomplete="off" placeholder="Type a message..." />
        <button id="send">Send</button>

        <script>
            const clientId = Math.floor(Math.random() * 10000);
            document.getElementById("ws-id").textContent = clientId;

            const ws = new WebSocket(`ws://localhost:8000/ws/${clientId}`);

            const input = document.getElementById("msg");
            const sendBtn = document.getElementById("send");
            const messages = document.getElementById("messages");

            ws.onmessage = (event) => {
                const li = document.createElement("li");
                li.textContent = event.data;
                messages.appendChild(li);
            };

            sendBtn.addEventListener("click", () => {
                if (input.value) {
                    ws.send(input.value);
                    input.value = "";
                }
            });
        </script>
    </body>
</html>
"""


# ---------------- WebSocket Manager ----------------
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def send_personal_message(self, message: str, websocket: WebSocket):
        await websocket.send_text(message)

    async def broadcast(self, message: str):
        for connection in self.active_connections:
            await connection.send_text(message)


manager = ConnectionManager()


# ---------------- Routes ----------------
@app.get("/")
async def get():
    return HTMLResponse(content=html)


@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: int):
    await manager.connect(websocket)
    db = SessionLocal()  # open db session

    try:
        await manager.broadcast(f"Client #{client_id} joined the chat")
        while True:
            data = await websocket.receive_text()

            # --- Save message to DB ---
            message = Message(sender_id=client_id, content=data)
            db.add(message)
            db.commit()
            db.refresh(message)
            # --------------------------

            await manager.send_personal_message(f"You wrote: {data}", websocket)
            await manager.broadcast(f"Client #{client_id} says: {data}")
    except Exception as e:
        print("Error:", e)
    finally:
        db.close()
        manager.disconnect(websocket)
        await manager.broadcast(f"Client #{client_id} left the chat")
